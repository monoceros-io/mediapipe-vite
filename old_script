<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Image Segmenter with Pose Landmarker</title>
    <style>
        body {
            padding: 0;
            margin: 0;
        }

        .qc {
            width: 50%;
            height: 50%;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .qc-0 {
            top: 0;
            left: 0;
            background-color: #999;
        }

        .qc-1 {
            top: 0;
            right: 0;
            background-color: #aaa;
        }

        .qc-2 {
            bottom: 0;
            left: 0;
            background-color: #bbb;
        }

        .qc-3 {
            bottom: 0;
            right: 0;
            background-color: #ccc;
        }

        .video {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .camera-select {
            position: absolute;
            top: 1em;
            left: 1em;
        }

        .output-canvas {
            /* width: 100%; */
            width: 100%;
            aspect-ratio: 1.7777;
        }

        .control-panel {
            position: absolute;
            padding: 1em;
            background-color: white;
            right: 0;
            bottom: 0;
        }
    </style>
</head>

<body>

    <div class="qc qc-0">
        <video id="vid-0" class="video"></video>
        <select name="cameras-0" id="cameras-0" class="camera-select"></select>

        </select>
    </div>
    <div class="qc qc-1">
        <canvas class="output-canvas" id="output-canvas-0"></canvas>
    </div>
    <div class="qc qc-2">
        <video id="vid-1" class="video"></video>
        <select name="cameras-1" id="cameras-1" class="camera-select"></select>
    </div>
    <div class="qc qc-3">
        <canvas class="output-canvas" id="output-canvas-1"></canvas>
    </div>

    <div class="control-panel">
        
    </div>

    <script type="module">


        import { ImageSegmenter, FilesetResolver, PoseLandmarker, DrawingUtils } from "./node_modules/@mediapipe/tasks-vision";

        const runningMode = "VIDEO";


        let wasmInstance = null;
        let wasmdrawInstance = null;

        const colors = [
            [255, 0, 0],   // Red BACKGROUND
            [0, 255, 0],   // Green HAIR
            [0, 0, 255],   // Blue SKIN
            [255, 255, 0], // Yellow FACE
            [0, 255, 255], // Cyan CLOTHES
            [255, 0, 255]  // Magenta OBJECTS
        ];

        const body = {
            head: [],
            shoulder0: [], shoulder1: [],
            hand0: [], hand1: [],
            foot0: [], foot1: []
        }

        let segmenter, poseLandmarker;

        let cameraSourceActive = [false, false];

        const cameraSelectors = document.querySelectorAll('.camera-select');

        let frameCounter = 0; // Counter to track frames
        let cameraDumpIndex = 0;
        const SEG_DIMENSION = 256;


        async function loadModels() {

            const vision = await FilesetResolver.forVisionTasks("./node_modules/@mediapipe/tasks-vision/wasm");

            segmenter = await ImageSegmenter.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "./selfie_multiclass_256x256.tflite",
                    delegate: 'GPU'
                },
                runningMode: runningMode,
            });


            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numPoses: 2
            });

        }



        const devices = await navigator.mediaDevices.enumerateDevices();
        devices.filter(device => device.kind === 'videoinput').forEach((device, index) => {
            for (let sel of cameraSelectors) {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `Camera ${index + 1}`;
                sel.appendChild(option);
                sel.selectedIndex = 2;
            }
        });

        cameraSelectors.forEach((sel, index) => {
            sel.addEventListener('change', async (event) => {
                cameraSourceActive[index] = false;
                const video = document.getElementById(`vid-${index}`);
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        frameRate: { min: 30, ideal: 60 },
                        aspectRatio: { exact: 16 / 9 },
                        deviceId: { exact: event.target.value },
                        width: { ideal: 4096 }, // Try for 4K width
                        height: { ideal: 2160 }, // Try for 4K height
                    }
                });

                const streamStart = () => {
                    video.removeEventListener('loadeddata', streamStart);
                    cameraSourceActive[index] = true;
                }

                video.addEventListener('loadeddata', streamStart);
                video.srcObject = stream;
                video.play();

            });
        });



        let poseUpdateInterval = 300; // 1 second
        let lastPoseTime = Date.now();
        let xThreshold = 0.1;
        let yThreshold = 0.1;

        function updatePose(landmark) {
            if (Date.now() - lastPoseTime > poseUpdateInterval) {

                lastPoseTime = Date.now();

                if (checkThreshold(landmark[0])) {
                    body.head[0] = landmark[0].x;
                    body.head[1] = landmark[0].y;
                }
                if (checkThreshold(landmark[11])) {
                    body.shoulder0[0] = landmark[11].x;
                    body.shoulder0[1] = landmark[11].y;
                }
                if (checkThreshold(landmark[12])) {
                    body.shoulder1[0] = landmark[12].x;
                    body.shoulder1[1] = landmark[12].y;
                }
                if (checkThreshold(landmark[15])) {
                    body.hand0[0] = landmark[15].x;
                    body.hand0[1] = landmark[15].y;
                }
                if (checkThreshold(landmark[16])) {
                    body.hand1[0] = landmark[16].x;
                    body.hand1[1] = landmark[16].y;
                }
                if (checkThreshold(landmark[27])) {
                    body.foot0[0] = landmark[27].x;
                    body.foot0[1] = landmark[27].y;
                }
                if (checkThreshold(landmark[28])) {
                    body.foot1[0] = landmark[28].x;
                    body.foot1[1] = landmark[28].y;
                }

            }
        }


        // const video = document.getElementById("vid-0");
        const videos = document.querySelectorAll("video");
        const canvases = document.querySelectorAll(".output-canvas");
        const dumpContexts = [
            canvases[0].getContext("2d"),
            canvases[1].getContext("2d")
        ];

        const offscreenCanvas = document.createElement("canvas");
        const offscreenCtx = offscreenCanvas.getContext("2d", { willReadFrequently: true });

        async function processVideoFrame() {


            cameraDumpIndex = +!cameraDumpIndex;

            if (!cameraSourceActive[cameraDumpIndex]) {
                requestAnimationFrame(processVideoFrame);
                return;
            }

            const video = videos[cameraDumpIndex];

            if (video.videoWidth === 0 || video.videoHeight === 0) {
                requestAnimationFrame(processVideoFrame);
                return;
            }

            offscreenCanvas.width = SEG_DIMENSION;
            offscreenCanvas.height = SEG_DIMENSION;
            offscreenCtx.drawImage(video, 0, 0, SEG_DIMENSION, SEG_DIMENSION);

            const imageData = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height);

            // Perform segmentation
            const segmentationResult = await segmenter.segmentForVideo(imageData, performance.now());
            if (segmentationResult?.confidenceMasks) {
                drawAllMasksToDumpCanvas(segmentationResult.confidenceMasks);
                segmentationResult.confidenceMasks.forEach(mask => mask.close());
            }

            if (Math.floor((cameraDumpIndex + frameCounter) / 2) % 10 === 0) {
                poseLandmarker.detectForVideo(video, performance.now(), drawPoseLandmarks);
            }

            frameCounter++;
            requestAnimationFrame(processVideoFrame);
        }


        let tempFloatBuffer = null;
        let lastBufferSize = 0;

        function drawAllMasksToDumpCanvas(confidenceMasks) {

            const canvas = canvases[cameraDumpIndex];
            const dumpCtx = dumpContexts[cameraDumpIndex];
            const { width, height } = confidenceMasks[0];
            const cMask = confidenceMasks[0];

            const pixelCount = width * height;

            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
            }

            // (Re)allocate buffer if needed
            if (!tempFloatBuffer || lastBufferSize !== pixelCount) {
                tempFloatBuffer = new Float32Array(pixelCount * 3); // R, G, B
                lastBufferSize = pixelCount;
            } else {
                tempFloatBuffer.fill(0);
            }

            [0, 4].forEach(maskIndex => {
                const maskData = confidenceMasks[maskIndex];
                const maskArray = maskData.getAsFloat32Array();
                const [r, g, b] = colors[maskIndex % colors.length];

                for (let i = 0; i < pixelCount; i++) {
                    const alpha = maskArray[i];
                    if (alpha === 0) continue;

                    const base = i * 3;
                    tempFloatBuffer[base] = Math.max(tempFloatBuffer[base], r * alpha);
                    tempFloatBuffer[base + 1] = Math.max(tempFloatBuffer[base + 1], g * alpha);
                    tempFloatBuffer[base + 2] = Math.max(tempFloatBuffer[base + 2], b * alpha);
                }
            });

            const imageData = dumpCtx.createImageData(width, height);
            const data = imageData.data;

            for (let i = 0, j = 0; i < pixelCount; i++, j += 4) {
                const base = i * 3;
                data[j] = tempFloatBuffer[base];     // R
                data[j + 1] = tempFloatBuffer[base + 1]; // G
                data[j + 2] = tempFloatBuffer[base + 2]; // B
                data[j + 3] = 255; // Opaque
            }

            dumpCtx.putImageData(imageData, 0, 0);
        }



        function checkThreshold(p) {
            return p.x > xThreshold && p.x < 1 - xThreshold &&
                p.y > yThreshold && p.y < 1 - yThreshold;
        }

        function drawPoseLandmarks(poseResult) {

            const dumpCtx = dumpContexts[cameraDumpIndex];

            const drawingUtils = new DrawingUtils(dumpCtx);

            for (const landmark of poseResult.landmarks) {

                updatePose(landmark);
                drawingUtils.drawLandmarks(landmark, {
                    radius: data => DrawingUtils.lerp(data.from.z, -0.15, 0.1, 5, 1)
                });
                drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);
            }
        }

        WebAssembly.instantiateStreaming(fetch("index.wasm"), {
            env: {
                memory: new WebAssembly.Memory({ initial: 512, maximum: 1024 }), // Increased memory
                abort: () => console.error("WASM aborted"),
            }
        }).then(result => {
            wasmInstance = result.instance;
            console.log("WANNO", wasmInstance);
        }).catch(err => {
            console.error("WASM failed to initialize", err);
        });

        await loadModels();

        if (!segmenter) {
            console.error("Segmenter not loaded.");
            // location.reload();
        }
        if (!poseLandmarker) {
            console.error("Pose not loaded.");
        }


        processVideoFrame();


    </script>
</body>

</html>